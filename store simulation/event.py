class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are less than those with newer
    timestamps.

    """
    def __init__(self, timestamp):
        """Initialize an Event with a given timestamp.

        @type self: Event
        @type timestamp: int
            A timestamp for this event.
            Precondition: must be a non-negative integer.
        @rtype: None

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    def __eq__(self, other):
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other):
        """Return True iff this Event is not equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other):
        """Return True iff this Event is less than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other):
        """Return True iff this Event is less than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other):
        """Return True iff this Event is greater than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other):
        """Return True iff this Event is greater than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store):
        """Perform this Event.

        Call methods on <store> to update its state according to the
        meaning of the event.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).

        @type self: Event
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        raise NotImplementedError


class Arrive(Event):
    """An  Arrive event.
    This event is resposible for putting the customer in the right line and giving the customer a joinTime that 
    indicated the time where he first arrived the store

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type name: str
        the name of a customer
    @type numItem: int
        the number of items the customer have
    @type status: str
        the status infor mation a Event(in this case "Arrive")
    @type joinTIme:int
        the time when the customer first showed up
    """    
    def __init__(self,timestamp,name,numItem,status,joinTime):
        self.timestamp=timestamp
        self.status=status
        self.name=name
        self.numItem=numItem
        self.joinTime=joinTime
    def do(self,store):
        servingLineNumber = store.findShortestLine(self.name,self.numItem,self.joinTime)
        servingLine = store.allCheckOutLine[servingLineNumber]
        if len(servingLine.customerInLine) == 1 :
            return [Begin(self.timestamp, self.name, self.numItem,servingLine,"Begin")]
        
   
class Begin(Event):
    """An  Begin event.
    This event is resposible for checking out the customer and giving the customer a leaving time

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type name: str
        the name of a customer
    @type numItem: int
        the number of items the customer have
    @type status: str
        the status infor mation a Event(in this case "Arrive")
    @type servingLine: CheckOutLine Object
        the line where the customer is checking out
    """      
    def __init__(self,timestamp,name,numItem,servingLine,status):
        self.timestamp=timestamp
        self.status=status
        self.name=name
        self.numItem=numItem
        self.servingLine=servingLine
    def do(self,store):
        processTime=self.servingLine.waitTime(self.numItem)
        return [Finish(self.timestamp+processTime, self.name, self.numItem,self.servingLine,"Finish")]
class Finish(Event):
    """An  Finish event.
    This event is resposible for removing the customer out of the line and check if there are people waiting behind

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type name: str
        the name of a customer
    @type numItem: int
        the number of items the customer have
    @type status: str
        the status infor mation a Event(in this case "Arrive")
    @type servingLine: CheckOutLine Object
        the line where the customer is checking out
    """         
    def __init__(self,timestamp,name,numItem,servingLine,status):
        self.timestamp=timestamp
        self.status=status
        self.name=name
        self.numItem=numItem
        self.servingLine=servingLine
        self.waitTime=0
    def do(self,store):
        self.servingLine.popCustomer()  #remove the finished customer from the line
        if len(self.servingLine.customerInLine) > 0:
            firstCustomer = self.servingLine.customerInLine[0]
            return [Begin(self.timestamp,firstCustomer.name,firstCustomer.numItem, self.servingLine,"Begin")]
    
    #helps to get the total wait time of a customer    
    def getWaitTime(self):
        return self.timestamp-self.servingLine.customerInLine[0].joinTime
        
class Close(Event):
    """An  Close event.
    This event is resposible for moving all the customers(except the first one) to another open line, and giving the line a Closed indication
    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type lineIndex: int
        the index of a line to be closed
    @type status: str
        the status infor mation a Event(in this case "Arrive")

    """         
    def __init__(self,timestamp,lineIndex,status):
        self.timestamp=timestamp
        self.status=status
        self.lineIndex=lineIndex
    def do(self,store):
        servingLine=store.allCheckOutLine[self.lineIndex]
        servingLine.closeLine()
        newEvents=[]
        count=0
        while len(servingLine.customerInLine)>1 :
            customer=servingLine.customerInLine[-1]
            newEvents.append(Arrive(self.timestamp+count, customer.name, customer.numItem,"Arrive",customer.joinTime))
            servingLine.customerInLine.pop(-1)
            count+=1
        return newEvents
                
    
def create_event_list(filename):
    """Return a list of Events based on raw list of events in <filename>.

    Precondition: the file stored at <filename> is in the format specified
    by the assignment handout.

    @param filename: str
        The name of a file that contains the list of events.
    @rtype: list[Event]
    """
    events = []
    with open(filename, 'r') as file:
        for line in file:
            tokens = line.split()
            if tokens[1] == 'Arrive':
                events.append(Arrive(int(tokens[0]), tokens[2], int(tokens[3]),"Arrive",int(tokens[0])))
            else:
                events.append(Close(int(tokens[0]),int(tokens[2]),"Close"))
    return events


if __name__ == '__main__':
    import doctest
    doctest.testmod()
